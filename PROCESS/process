						process

1.进程

	 a.程序时静态的，它是一些保存 在磁盘上得指令的有序集合，没有任何执行的概念。
进程是一个动态的概念，它是程序执行的过程，包括创建、调度和消亡。
	
	 b.进程状态
	 
	 Ready 	  			就绪状态
[R]	 Executeing			执行状态
[D]	 Uninterruptible 	不可中断睡眠状态,直到外部调用资源成功，如内核的某些处理流程是不能被打断的
[S]	 Interruptible  	可中断睡眠状态,随时可唤醒,如http等
[T]	 Stopped  			停止状态,不能在cpu上运行
[Z]	 Zombie				僵尸状态,内核无法捕捉与释放的进程
	 
	 c.init(PID=1)是所有进程的父进程
	 
	 d.进程优先级:(0-99)	内核调整
				  (100-139)	用户调整

				  
2.查看进程

	ps aux
		a:所有跟终端有关的进程
		u:显示进程的发起者
		x:所有跟终端无关的进程
	
	USER : 发起者
	PID : 进程号(与/proc下的数字相对应,每个目录分别为各自进程的属性)
	%CPU : 占有cpu百分比
	%MEM : 占有内存的百分比
	VSZ :  占用的虚拟内存大小(byte)
	RSS :  占用的内存大小(byte)
	TTY  : 所关联的终端,"?"表示跟终端无关     
	STAT : 进程状态[R,D,S,T,Z,<(优先级高的进程),N(优先级低的进程),s(进程的领导者,在它之下有子进程),
			l(多线程进程),+(位于后台的进程)]
	START :	启动进程的时间
	TIME : 	CPU运行时间 (s)
	COMMAND : 命令的名称和参数
	
	-----------------------------------------------------------------------------------
	
	ps -el
		e:显示所有程序
		l:采用详细的格式来显示程序状况

	PPID : 父进程  
	PRI : 进程或内核线程的优先级；数字越大优先级越低  
	NI  : nice值
	
	-----------------------------------------------------------------------------------
	
	pstree   显式进程树
	
	-----------------------------------------------------------------------------------
	
	top  可以实时动态地查看系统的整体运行情况
	
	
		1:展开显示各个cpu信息
		M:根据驻留内存大小进行排序 
		P:根据CPU使用百分比大小进行排序 
		T:根据累计时间进行排序
		t:是否显示进程和CPU状态信息 
		c:是否显示命令名称和完整命令行
		k:终止一个进程
		q:退出top

		top - 09:44:56 up[当前系统时间] 
		16 days[系统已经运行了16天]
		1 user[个用户当前登录]
		load average: 9.59, 4.75, 1.92[系统负载，即任务队列的平均长度] 
		Tasks: 145 total[总进程数], 2 running[正在运行的进程数], 143 sleeping[睡眠的进程数], 
		0 stopped[停止的进程数], 0 zombie[冻结进程数]
		Cpu(s): 99.8%us[用户空间占用CPU百分比], 0.1%sy[内核空间占用CPU百分比], 
		0.0%ni[用户进程空间内改变过优先级的进程占用CPU百分比], 0.2%id[空闲CPU百分比], 
		0.0%wa[等待输入输出的CPU时间百分比], 0.0%hi[硬件中断所占的CPU时间百分比], 
		0.0%st[被偷走的时间]
		Mem: 4147888k total[物理内存总量], 2493092k used[使用的物理内存总量], 
		1654796k free[空闲内存总量], 158188k buffers[用作内核缓存的内存量] 
		Swap:  5144568k total[交换区总量], 56k used[使用的交换区总量], 
		5144512k free[空闲交换区总量], 2013180k cached[缓冲的交换区总量], 


3.进程管理

	a.进程信号
	
	1 ------ SIGHUP --------- 让一个程序不重启,重新读取其配置文件
	2 ------ SIGINT --------- 中断(同Ctrl + C)
	9 ------ SIGKILL -------- 终止一个进程,不等待其释放所有资源
	15 ----- SIGTERM -------- 终止一个进程,等待其释放所有资源(kill默认信号)

	b.传送信号
	
		kill -s [1|SIGHUP] PID
		killall COMMAND  #使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程
	
	c.调整nice值(值-20~19对应100~139)
		
		nice -n NI值 COMMAND  #用于以指定的进程调度优先级启动其他的程序。
		
		renice NI值 PID		 #可以修改正在运行的进程的调度优先级

	d.作业管理(job)
		
		前台运行:占据整个命令提示符
		后台运行:释放命令提示符,后续操作在后台完成
		
		-------------------------查看后台作业---------------------------------------
	
			jobs
			
			+:表示默认操作(fg,bg)
			-:表示下一次执行的操作
			" ":表示等待
			[3]   Stopped           	vim c
			[1]-  Stopped               vim a
			[2]+  Stopped               vim b
			
		-----------------------前后台切换----------------------------------
		
			前===>>后
					ctrl + z  把已经正在前台的作业送往后台(Stopped)
					COMMAND & 让命令在后台执行
					
			后===>>前
					fg #
					
		------------------------其他操作-----------------------------
		
					bg #        让后台程序从Stoppe启动(该命令的运行效果与在指令后面添加符号
								&的效果是相同的)
					kill %#     杀死job#
					
4.查看系统状态

	vmstat 事件间隔(状态信息刷新的时间间隔) 次数(显示报告的次数)
	
	================================================================================
	
	Procs（进程） 
			r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1） 
			b: 等待IO的进程数量。 
	Memory（内存） 
			swpd: 使用虚拟内存大小如果swpd的值不为0，但是SI，SO的值长期为0，
					这种情况不会影响系统性能。

			free: 空闲物理内存大小。 
			buff: 用作缓冲的内存大小。 
			cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，
					如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 
	Swap 
			si: 每秒从交换区写到内存的大小，由磁盘调入内存。 
			so: 每秒写入交换区的内存大小，由内存调入磁盘。注意：内存够用的时候，这2个值都是0，
				如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。
	IO（现在的Linux版本块的大小为1kb） 
			bi: 每秒读取的块数 
			bo: 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，
			能看到CPU在IO等待的值也会越大。 
	system（系统） 
			in: 每秒中断数，包括时钟中断。 
			cs: 每秒上下文切换数。 注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。 
	CPU（以百分比表示） 
			us: 用户进程执行时间百分比(user time) us的值比较高时，说明用户进程消耗的CPU时间多，
				但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。 
			sy: 内核系统进程执行时间百分比(system time) sy的值高时，说明系统内核消耗的CPU资源多，
				这并不是良性表现，我们应该检查原因。 
			wa: IO等待时间百分比 wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问
				造成，也有可能磁盘出现瓶颈（块操作）。 
			id: 空闲时间百分比


